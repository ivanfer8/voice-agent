<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>ZIM - Agendamiento de Instalaciones</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%);
      color: #e5e7eb;
      display: flex;
      justify-content: center;
      align-items: stretch;
    }

    .app {
      width: 100%;
      max-width: 1180px;
      padding: 1.5rem 1.25rem 2rem;
      display: flex;
      flex-direction: column;
      gap: 1.25rem;
    }

    /* Top bar */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .brand img {
      height: 48px;
      width: auto;
    }
    .brand-title {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }
    .brand-title h1 {
      margin: 0;
      font-size: 1.4rem;
      letter-spacing: 0.02em;
    }
    .brand-title span {
      font-size: 0.78rem;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .topbar-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.2rem;
      font-size: 0.82rem;
      color: #9ca3af;
    }

    /* Layout principal */
    .main-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 1.25rem;
    }
    @media (max-width: 980px) {
      .main-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: rgba(15, 23, 42, 0.96);
      border-radius: 1.1rem;
      padding: 1.1rem 1.1rem 1.2rem;
      border: 1px solid rgba(148, 163, 184, 0.22);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.85);
    }
    .card h2 {
      margin: 0 0 0.85rem;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #9ca3af;
    }

    /* Panel de llamada (lado izquierdo) */
    .call-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      gap: 0.75rem;
    }
    .agent-info {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .agent-avatar {
      width: 54px;
      height: 54px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #facc15 0, #f97316 35%, #7c2d12 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 1.1rem;
      color: #0b1120;
      box-shadow: 0 10px 25px rgba(251, 191, 36, 0.5);
    }
    .agent-text {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }
    .agent-text span:first-child {
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .agent-text strong {
      font-size: 1.05rem;
    }

    .call-status-pill {
      padding: 0.2rem 0.7rem;
      border-radius: 999px;
      border: 1px solid rgba(52, 211, 153, 0.6);
      font-size: 0.78rem;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: rgba(6, 78, 59, 0.2);
      color: #6ee7b7;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 10px #22c55e;
    }
    .call-status-pill.idle {
      border-color: rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.7);
      color: #9ca3af;
    }
    .call-status-pill.idle .status-dot {
      background: #9ca3af;
      box-shadow: none;
    }
    .call-status-pill.ringing {
      border-color: rgba(59, 130, 246, 0.75);
      background: rgba(15, 23, 42, 0.8);
      color: #93c5fd;
    }
    .call-status-pill.ringing .status-dot {
      background: #3b82f6;
      box-shadow: 0 0 10px #3b82f6;
    }

    .call-body {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    /* Bot√≥n de llamada */
    #btnToggle {
      border: none;
      border-radius: 999px;
      padding: 0.75rem 2.2rem;
      font-size: 1.05rem;
      cursor: pointer;
      background: radial-gradient(circle at top left, #22c55e 0, #16a34a 55%, #166534 100%);
      color: #0b1120;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.55rem;
      box-shadow: 0 12px 30px rgba(34, 197, 94, 0.45);
      transition: transform 0.08s ease-out, box-shadow 0.08s ease-out,
        background 0.15s ease-out;
    }
    #btnToggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 38px rgba(34, 197, 94, 0.55);
    }
    #btnToggle.recording {
      background: radial-gradient(circle at top left, #ef4444 0, #b91c1c 55%, #7f1d1d 100%);
      box-shadow: 0 12px 30px rgba(239, 68, 68, 0.6);
      color: #fee2e2;
    }
    #btnToggle span.icon {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 2px solid currentColor;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.95rem;
    }

    /* Burbujas de texto */
    .conversation {
      width: 100%;
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 0.75rem;
      margin-top: 0.75rem;
    }
    @media (max-width: 680px) {
      .conversation {
        grid-template-columns: minmax(0, 1fr);
      }
    }
    .bubble-block-title {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 0.2rem;
    }
    .bubble {
      border-radius: 0.9rem;
      padding: 0.7rem 0.9rem;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(75, 85, 99, 0.8);
      min-height: 2.3rem;
      font-size: 0.95rem;
      white-space: pre-wrap;
      color: #e5e7eb;
    }
    .bubble.user {
      border-color: rgba(96, 165, 250, 0.95);
      background: rgba(15, 23, 42, 0.98);
    }
    .bubble.agent {
      border-color: rgba(52, 211, 153, 0.9);
      background: rgba(6, 78, 59, 0.24);
    }

    /* Panel lateral (config + logs) */
    .config-group {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      margin-bottom: 0.9rem;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      font-size: 0.85rem;
    }
    .field label {
      color: #9ca3af;
    }
    .field input,
    .field select {
      background: #020617;
      color: #e5e7eb;
      border-radius: 0.6rem;
      border: 1px solid #4b5563;
      padding: 0.45rem 0.55rem;
      font-size: 0.9rem;
    }
    .hint {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    /* Logs */
    .logs-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.8rem;
      color: #9ca3af;
      cursor: pointer;
      margin-top: 0.4rem;
    }
    .logs-toggle span.chevron {
      transition: transform 0.15s ease-out;
    }
    .logs-toggle.open span.chevron {
      transform: rotate(90deg);
    }
    #log-container {
      margin-top: 0.45rem;
      display: none;
    }
    #log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      background: #020617;
      border-radius: 0.6rem;
      padding: 0.7rem;
      border: 1px solid rgba(55, 65, 81, 0.9);
      height: 230px;
      overflow-y: auto;
      white-space: pre-wrap;
      color: #9ca3af;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <img src="zim-logo.png" alt="ZIM" />
        <div class="brand-title">
          <span>Plataforma ZIM</span>
          <h1>Agendamiento de Instalaciones</h1>
        </div>
      </div>
      <div class="topbar-right">
        <div id="topClientName">Cliente demo: (sin nombre)</div>
        <div id="topTts">Motor de voz: OpenAI TTS</div>
      </div>
    </div>

    <div class="main-grid">
      <!-- Panel de llamada -->
      <section class="card">
        <h2>Llamada simulada</h2>

        <div class="call-header">
          <div class="agent-info">
            <div class="agent-avatar">Z</div>
            <div class="agent-text">
              <span>Agente comercial ¬∑ Zener para Vodafone</span>
              <strong>Agente virtual de agendamiento</strong>
            </div>
          </div>
          <div id="callStatus" class="call-status-pill idle">
            <span class="status-dot"></span>
            <span id="callStatusText">Listo para llamar</span>
          </div>
        </div>

        <div class="call-body">
          <button id="btnToggle">
            <span class="icon">üìû</span>
            <span>Iniciar llamada</span>
          </button>

          <div class="conversation">
            <div>
              <div class="bubble-block-title">T√∫ dijiste</div>
              <div class="bubble user" id="userText">
                Pulsa ‚ÄúIniciar llamada‚Äù, espera a los tonos de establecimiento y habla como si fueses el cliente.
              </div>
            </div>
            <div>
              <div class="bubble-block-title">El agente responde</div>
              <div class="bubble agent" id="agentText">
                Aqu√≠ aparecer√°n las respuestas del agente de Zener en nombre de Vodafone durante la llamada.
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Panel lateral: config + logs -->
      <section class="card">
        <h2>Panel de demo</h2>

        <div class="config-group">
          <div class="field">
            <label for="clientName">Nombre del cliente (para la demo)</label>
            <input id="clientName" type="text" placeholder="Ej: Iv√°n Fern√°ndez" />
            <div class="hint">
              Solo visual: sirve para mostrar en la cabecera con qui√©n est√° ‚Äúhablando‚Äù el agente y se usa en el saludo inicial.
            </div>
          </div>

          <div class="field">
            <label for="ttsProvider">Motor de voz</label>
            <select id="ttsProvider">
              <option value="openai">OpenAI TTS</option>
              <option value="elevenlabs">ElevenLabs TTS</option>
            </select>
            <div class="hint">
              Cambia el motor de voz en caliente. El flujo de IA es el mismo, solo cambia qui√©n sintetiza la voz.
            </div>
          </div>
        </div>

        <div class="hint">
          <strong>C√≥mo usar la demo:</strong><br />
          1) Escribe un nombre de cliente (opcional).<br />
          2) Elige el motor de voz.<br />
          3) Pulsa <em>Iniciar llamada</em>, escucha los tonos de establecimiento (solo la primera vez) y habla como si fueses el cliente
          al otro lado del tel√©fono.
        </div>

        <div class="logs-toggle" id="logsToggle">
          <span class="chevron">‚ñ∂</span>
          <span>Ver detalles t√©cnicos (logs)</span>
        </div>
        <div id="log-container">
          <pre id="log"></pre>
        </div>
      </section>
    </div>
  </div>

<script>
  const btn = document.getElementById('btnToggle');
  const logEl = document.getElementById('log');
  const userTextEl = document.getElementById('userText');
  const agentTextEl = document.getElementById('agentText');
  const callStatusEl = document.getElementById('callStatus');
  const callStatusTextEl = document.getElementById('callStatusText');
  const clientNameInput = document.getElementById('clientName');
  const topClientNameEl = document.getElementById('topClientName');
  const ttsSelect = document.getElementById('ttsProvider');
  const topTtsEl = document.getElementById('topTts');
  const logsToggle = document.getElementById('logsToggle');
  const logContainer = document.getElementById('log-container');

  let mediaRecorder;
  let audioStream;
  let socket;
  let isCallActive = false;
  let ringInterval = null;
  let hasRungOnce = false; // tonos solo primera vez

  // Historial de conversaci√≥n para mandar al backend
  let conversationHistory = [];

  // Detecci√≥n de silencios (para ‚Äúmanos libres‚Äù)
  let currentUtteranceChunks = [];
  let silenceSlices = 0;
  const TIMESLICE_MS = 500;             // cada 500 ms llega un chunk
  const SILENCE_THRESHOLD_BYTES = 2000; // por debajo de esto = casi silencio
  const MAX_SILENCE_SLICES = 6;         // ~ 3 s de silencio => cerramos frase

  function addLog(msg) {
    logEl.textContent += msg + '\n';
    logEl.scrollTop = logEl.scrollHeight;
    console.log(msg);
  }

  // Actualizar cabecera con nombre y TTS
  clientNameInput.addEventListener('input', () => {
    const name = clientNameInput.value.trim();
    topClientNameEl.textContent = name
      ? 'Cliente demo: ' + name
      : 'Cliente demo: (sin nombre)';
  });

  ttsSelect.addEventListener('change', () => {
    const label =
      ttsSelect.value === 'elevenlabs'
        ? 'ElevenLabs TTS'
        : 'OpenAI TTS';
    topTtsEl.textContent = 'Motor de voz: ' + label;
  });

  // Mostrar/ocultar logs
  logsToggle.addEventListener('click', () => {
    const open = logContainer.style.display === 'block';
    logContainer.style.display = open ? 'none' : 'block';
    logsToggle.classList.toggle('open', !open);
  });

  // Gesti√≥n de estados visuales de la llamada
  function setCallStatus(mode) {
    callStatusEl.classList.remove('idle', 'ringing');
    if (mode === 'ringing') {
      callStatusEl.classList.add('ringing');
      callStatusTextEl.textContent = 'Llamando al agente...';
    } else if (mode === 'active') {
      callStatusTextEl.textContent = 'En llamada';
    } else {
      callStatusEl.classList.add('idle');
      callStatusTextEl.textContent = 'Listo para llamar';
    }
  }

  // Simular tonos de establecimiento (ring)
  function startRingTone() {
    stopRingTone();
    try {
      const AudioContext =
        window.AudioContext || window.webkitAudioContext;
      const ctx = new AudioContext();

      function playBeep() {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 440;
        osc.connect(gain);
        gain.connect(ctx.destination);
        gain.gain.setValueAtTime(0.0001, ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.08, ctx.currentTime + 0.05);
        gain.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + 0.9);
        osc.start();
        osc.stop(ctx.currentTime + 1.0);
      }

      playBeep();
      ringInterval = setInterval(playBeep, 1600);
      ringInterval._audioCtx = ctx;
    } catch (e) {
      addLog('No se ha podido iniciar el tono de llamada: ' + e.message);
    }
  }

  function stopRingTone() {
    if (ringInterval) {
      clearInterval(ringInterval);
      if (ringInterval._audioCtx) {
        try {
          ringInterval._audioCtx.close();
        } catch {}
      }
      ringInterval = null;
    }
  }

  // ---- Enviar una ‚Äúfrase‚Äù completa a /stt ----
  async function sendUtteranceToStt(blob) {
    try {
      addLog('Frase detectada, tama√±o total: ' + blob.size);

      const formData = new FormData();
      formData.append('audio', blob, 'grabacion.webm');

      // Motor de voz
      const ttsProvider = ttsSelect ? ttsSelect.value : 'openai';
      formData.append('ttsProvider', ttsProvider);

      // Nombre del cliente (para saludo inicial y uso en el prompt)
      const clientName = clientNameInput ? clientNameInput.value : '';
      formData.append('clientName', clientName);

      // Historial
      formData.append('history', JSON.stringify(conversationHistory));

      addLog('Enviando frase a /stt...');
      const resp = await fetch('/stt', {
        method: 'POST',
        body: formData
      });

      if (!resp.ok) {
        const errText = await resp.text();
        addLog('Error STT HTTP: ' + resp.status + ' - ' + errText);
        return;
      }

      const data = await resp.json();

      if (data.transcript) {
        userTextEl.textContent = data.transcript;
        conversationHistory.push({
          role: 'user',
          content: data.transcript
        });
      } else {
        userTextEl.textContent = '(no se ha entendido nada claro)';
      }

      if (data.answer) {
        agentTextEl.textContent = data.answer;
        conversationHistory.push({
          role: 'assistant',
          content: data.answer
        });
      }

      if (conversationHistory.length > 10) {
        conversationHistory = conversationHistory.slice(
          conversationHistory.length - 10
        );
      }

      addLog('Transcripci√≥n: ' + (data.transcript || ''));
      addLog('Respuesta IA (texto): ' + (data.answer || ''));

      if (data.audio) {
        try {
          addLog('Reproduciendo audio de respuesta...');
          const audioBytes = Uint8Array.from(
            atob(data.audio),
            (c) => c.charCodeAt(0)
          );
          const audioBlob = new Blob([audioBytes], {
            type: 'audio/mpeg'
          });
          const url = URL.createObjectURL(audioBlob);
          const audio = new Audio(url);
          audio.play();
        } catch (e) {
          addLog('Error reproduciendo audio: ' + e.message);
        }
      }
    } catch (err) {
      addLog('Error llamando a /stt: ' + err.message);
    }
  }

  // ---- Iniciar llamada (mic abierto todo el rato, detecci√≥n de pausas) ----
  async function startCall() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      addLog(
        'ERROR: getUserMedia NO disponible (necesitas HTTPS o localhost).'
      );
      return;
    }

    try {
      addLog('Pidiendo permiso de micr√≥fono...');
      audioStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: false
        }
      });
      addLog('Permiso de micr√≥fono CONCEDIDO.');

      mediaRecorder = new MediaRecorder(audioStream);

      mediaRecorder.onstart = () => {
        addLog('MediaRecorder iniciado (llamada activa)');
        setCallStatus('active');
        // reseteamos buffers por si acaso
        currentUtteranceChunks = [];
        silenceSlices = 0;
      };

      mediaRecorder.ondataavailable = (e) => {
        // Este evento se dispara cada TIMESLICE_MS con un trocito de audio
        addLog('Chunk de audio generado, tama√±o: ' + e.data.size);

        // Opcional: seguir enviando al WS como debug (como antes)
        if (e.data.size > 0 && socket && socket.readyState === WebSocket.OPEN) {
          e.data.arrayBuffer().then((buf) => {
            addLog(
              'Enviando chunk de audio al servidor (' +
                buf.byteLength +
                ' bytes)'
            );
            socket.send(buf);
          });
        }

        // --- L√≥gica simple de detecci√≥n de silencios ---
        if (e.data.size < SILENCE_THRESHOLD_BYTES) {
          // lo consideramos silencio
          silenceSlices++;
        } else {
          // hay voz
          silenceSlices = 0;
          currentUtteranceChunks.push(e.data);
        }

        // Si acumulamos suficiente silencio despu√©s de haber tenido voz,
        // damos por terminada la "frase" y la mandamos a /stt.
        if (
          silenceSlices >= MAX_SILENCE_SLICES &&
          currentUtteranceChunks.length > 0
        ) {
          const utteranceBlob = new Blob(currentUtteranceChunks, {
            type: 'audio/webm'
          });
          // Limpieza para la siguiente frase
          currentUtteranceChunks = [];
          silenceSlices = 0;

          // Mandamos la frase al backend
          sendUtteranceToStt(utteranceBlob);
        }
      };

      mediaRecorder.onstop = () => {
        addLog('MediaRecorder parado (llamada finalizada)');
        setCallStatus('idle');

        // Al colgar, si quedaba algo de audio sin mandar, lo enviamos
        if (currentUtteranceChunks.length > 0) {
          const utteranceBlob = new Blob(currentUtteranceChunks, {
            type: 'audio/webm'
          });
          currentUtteranceChunks = [];
          silenceSlices = 0;
          sendUtteranceToStt(utteranceBlob);
        }

        // Parar tambi√©n el stream de audio
        if (audioStream) {
          audioStream.getTracks().forEach((t) => t.stop());
          audioStream = null;
        }
      };

      mediaRecorder.start(TIMESLICE_MS);
      isCallActive = true;
      btn.classList.add('recording');
      btn.querySelector('span:nth-child(2)').textContent =
        'Colgar llamada';
    } catch (err) {
      addLog(
        'ERROR al pedir el micr√≥fono: ' +
          err.name +
          ' - ' +
          err.message
      );
      setCallStatus('idle');
    }
  }

  // ---- Finalizar llamada ----
  function stopCall() {
    stopRingTone();
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    } else {
      // si por lo que sea no est√° activo pero hay stream, lo paramos
      if (audioStream) {
        audioStream.getTracks().forEach((t) => t.stop());
        audioStream = null;
      }
    }

    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.close();
    }
    isCallActive = false;
    btn.classList.remove('recording');
    btn.querySelector('span:nth-child(2)').textContent =
      'Iniciar llamada';
  }

  // ---- Bot√≥n principal: iniciar/colgar ----
  btn.onclick = async () => {
    if (!isCallActive) {
      // Conexi√≥n WS (igual que antes, solo debug)
      const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
      const wsUrl = `${protocol}://${location.host}`;
      addLog('Conectando WebSocket a: ' + wsUrl);

      socket = new WebSocket(wsUrl);
      socket.binaryType = 'arraybuffer';

      socket.onopen = () => {
        addLog('WS conectado');
      };

      socket.onmessage = (event) => {
        addLog('Respuesta servidor: ' + event.data);
      };

      socket.onclose = () => addLog('WS cerrado');
      socket.onerror = () => addLog('WS error');

      // Primera vez: tonos de llamada
      if (!hasRungOnce) {
        setCallStatus('ringing');
        startRingTone();
        btn.classList.add('recording');
        btn.querySelector('span:nth-child(2)').textContent =
          'Colgar llamada';

        setTimeout(() => {
          stopRingTone();
          hasRungOnce = true;
          startCall();
        }, 2500); // ~2.5s de ‚Äúllamando‚Äù
      } else {
        // Siguientes: ya sin tonos
        setCallStatus('active');
        btn.classList.add('recording');
        btn.querySelector('span:nth-child(2)').textContent =
          'Colgar llamada';
        startCall();
      }
    } else {
      // Colgar
      stopCall();
    }
  };
</script>

</body>
</html>
